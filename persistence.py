import sqlite3
import subprocess
from importlib import import_module
from pathlib import Path

DBNAME = "db.sqlite3"


"""
Forward-only DB migration scheme held together by duct tape.

- Uses `user_version` pragma to figure out what migrations are pending.

- Each migration file (./migrations/mXXXX.py) has a `migrate(cursor)` function that
  should run cursor.execute() as needed.

Reason I can't use .sql migration files is because python's sqlite3 lib tries to be a
smartass and attempts to begin/commit transactions behind my back. Even with
isolation_level=None, the `cursor.executescript()` function still wants to do a COMMIT
and blows up my whole rollback scheme. Therefore executescript() is out, meaning writing
multi-statement sql files is also out. But hey having python-based migration scripts may
come in handy someday.
"""


def get_conn(*args, **kwargs):
    return sqlite3.connect(DBNAME, *args, **kwargs)


def get_all_migrations():
    return sorted(Path("migrations").glob("m*.py"))


def get_version(migration: Path):
    return int(migration.name[1:-3])


def get_current_version():
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("PRAGMA user_version")
    version = int(cur.fetchone()[0])
    conn.close()
    return version


def get_pending_migrations():
    current_version = get_current_version()
    migrations = get_all_migrations()
    return [
        migration
        for migration in migrations
        if get_version(migration) > current_version
    ]


def import_migrations(paths):
    migrations = [
        (path, import_module(f"migrations.{path.name[:-3]}").migrate) for path in paths
    ]
    return migrations


def write_db_schema_script():
    schema = subprocess.run(
        ["sqlite3", DBNAME, ".schema"], capture_output=True, check=True
    ).stdout
    with open("migrations/latest_schema.sql", "wb") as f:
        f.write(b"-- This file is auto-generated by the migration script\n")
        f.write(b"-- for reference purposes only. DO NOT EDIT.\n\n")
        f.write(schema)


def migrate():
    pending_migrations = get_pending_migrations()

    if not pending_migrations:
        print("Nothing to migrate.")
        exit()

    print(f"There are {len(pending_migrations)} pending migrations.")

    migrations_funcs = import_migrations(pending_migrations)

    conn = get_conn(isolation_level=None)
    cursor = conn.cursor()
    cursor.execute("BEGIN")
    try:
        for path, migrate_func in migrations_funcs:
            print("Migrating", path.name, "...")
            migrate_func(cursor)
            cursor.execute(f"PRAGMA user_version = {get_version(path)}")
        cursor.execute("COMMIT")
    except Exception:
        cursor.execute("ROLLBACK")
        print("Rolled back.")
        raise
    finally:
        conn.close()

    write_db_schema_script()

    print("All done. Current version:", get_current_version())


if __name__ == "__main__":
    migrate()
